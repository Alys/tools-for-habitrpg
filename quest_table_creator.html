<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Habitica Wiki Quest Table Creator</title>

<!--

This page outputs the wikia code for creating tables displaying quest information in Habitica's official wiki.

It's primarily written for the English language wiki (http://habitica.fandom.com/wiki/)
but can also be used for other languages by specifying the language code in the URL like this:
    https://oldgods.net/habitrpg/quest_table_creator.html?language=en
That will cause Habitica's official content translations to be used.

For texts inserted by this page (e.g., table headers), additional translations need to be added
to the `stringsForLanguage` and `regexpsForLanguage` and `templateNamesForLanguage` objects in this file.
For some languages, `reverseTextForLanguage` might also need to be edited.
Contact Alys (details below) if you'd like to provide translations for your language.

This code is licenced under the same terms as Habitica:
    https://raw2.github.com/HabitRPG/habitrpg/develop/LICENSE

https://github.com/Alys/tools-for-habitrpg/blob/master/quest_table_creator.html

https://oldgods.net/habitrpg/quest_table_creator.html

Contributors:
    Alys (Alice Harris), lady_alys@oldgods.net
    Jazzis (Yuri Mashukov), jazzis18@gmail.com (Russian translation and code improvements)

-->

    <meta name="description" content="Habitica Wiki Quest Table Creator" />
    <meta name="author" content="Alys (Alice Harris) lady_alys@oldgods.net" />

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="//cdn.datatables.net/1.10.10/js/jquery.dataTables.min.js"></script>
    <link href="//cdn.datatables.net/1.10.10/css/jquery.dataTables.min.css" rel="stylesheet" type="text/css" />


<script type="text/javascript">
$(function() { // wraps around all our code to not pollute global namespace


//////////////////////////////////////////////////////////////////////
////   TRANSLATED STRINGS                              ///////////////
////                                                   ///////////////
////   Add strings that this page uses (not strings    ///////////////
////   that are found in Habitica).                    ///////////////
////                                                   ///////////////
//////////////////////////////////////////////////////////////////////
var stringsForLanguage = {
    'en': {
        WIKI_URL:         "https://habitica.fandom.com/wiki/", // the part of the URL that appears in all wiki pages for this language

        checkins:         "Check-Ins", // an abbreviated name for the language-specific version of the http://habitica.fandom.com/wiki/Daily_Check-In_Incentives page
        checkins_page:    "Daily_Check-In_Incentives", // link to the page itself above

        level:            "level",
        equipment:        "equipment",
        scroll:           "scroll", // quest scroll
        pet:              "pet",
        mount:            "mount",
        egg:              "egg",
        food:             "food",
        hatching_potion:  "hatching potion",
        pet_and_mount:    "pet &amp; mount",
        GP:               "GP", // abbreviation for Gold / Gold Points
        XP:               "XP", // abbreviation for Experience / Experience Points
        gems:             "Gems",
        world_boss:       "world boss", // as in 'world boss quest'
        collection:       "collection", // as in 'collection quest'
        boss:             "boss",       // as in 'boss quest'
        rage:             "rage",       // some bosses have a 'rage' meter
        unknown:          "unknown",    // used when we don't know the quest type (world boss/boss/collection) or the reward type

        name:             "name",               // table header for the quest name column
        availability:     "availability",       // table header: how / when to obtain the scroll
        type:             "type",               // table header: type of quest (world boss or boss or collection)
        rewards:          "rewards",            // table header: rewards that the quest gives
        boss_HP:          "boss<br />HP",       // table header: starting health of boss
        boss_strength:    "boss<br />strength", // table header: strength of boss

        length:           "length",       // table header (HTML only): the length of time generally taken to complete a quest
        difficulty:       "difficulty",   // table header (HTML only): how difficult a quest is in terms of having to be consistent with your Dailies
        rating:           "rating",       // table header (HTML only): a merge of the length and difficulty
        release_date:     "release date", // table header (HTML only): quest release date

        previous_part:    "previous part",   // this text indicates that you can get the quest scroll when you complete the previous quest in the chain
        invite_to_party:  "invite to party", // used to indicate that you get the quest scroll when you invite someone to your party and they accept
        create_account:   "Create Account",  // this must be identical to Habitica's `createAccountReward` translated string
        finished:         "finished", // indicates that the World Boss quest has finished and is no longer available
        only_during:      "only during",  // used to indicate availability for quests that can be bought only during a specific Grand Gala
        XP_GP_only:       "XP, GP<br />only", // the reward type for quests that give only XP and GP
        various:          "various", // used to indicate the quest rewards when there's a variety of them
        etc:              "etc", // added to the end of the quest's reward type when the quest gives multiple types
        one_of_each_food: "one of each food", // a type of quest reward
        not_applicable:   "n/a", // an abbreviation meaning 'not applicable' (recommended to use a short word)

        weeks:            "wk",   // 'weeks' or a shorter word for it (as short as possible is best)
        short:            "short",  // describes the length of time generally taken to complete a quest
        medium:           "medium", // as above
        long:             "long",   // as above

        very_hard:        "very hard", // describes how difficult a quest is in terms of having to be consistent with your Dailies
        hard:             "hard",      // as above
        medium:           "medium",    // as above
        easy:             "easy",      // as above
        trivial:          "trivial",   // as above

        million:          "M",  // an abbreviation for 'million' to indicate the strength of world boss or his rage
        or:               "or",
        or_earlier:       "or earlier",

        new_quest:        "Quest released this month", // used only within this page's instructions; will not appear on the wiki
        tables_to_edit:   "update the tables for", // used only within this page's instructions; will not appear on the wiki
        all_quests:       "All Quests", // subsection heading used only within this page's instructions
        quest_lines:      "Quest Lines", // subsection heading used only within this page's instructions
        easy_quests:      "Easy Quests", // subsection heading used only within this page's instructions
        medium_quests:    "Medium Quests", // subsection heading used only within this page's instructions
        hard_quests:      "Hard Quests", // subsection heading used only within this page's instructions
    },
    'ru': { // XXX_LATER apply changes to comments above to these comments
        WIKI_URL:         "https://habitica.fandom.com/ru/wiki/", // the part of the URL that appears in all wiki pages for this language

        checkins:         "вх. в игру", // an abbreviated name for the language-specific version of the http://habitica.fandom.com/wiki/Daily_Check-In_Incentives page
        checkins_page:    "Ежедневное_вознаграждение", // link to the page itself above

        level:            "ур.",
        equipment:        "снаряжение",
        scroll:           "свиток", // quest scroll
        pet:              "питомец",
        mount:            "скакун",
        egg:              "яйцо",
        food:             "еда",
        hatching_potion:  "инкубационный эликсир",
        pet_and_mount:    "питомец и скакун",
        GP:               "золота", // abbreviation for Gold / Gold Points
        XP:               "опыт",   // abbreviation for Experience / Experience Points
        gems:             "самоцв.",
        world_boss:       "мировой босс",
        collection:       "собираемый",    // as in "collection quest"
        boss:             "босс",          // as in "boss quest"
        rage:             "ярость",        // some bosses have a "rage" meter
        unknown:          "неизвестно",    // used when we don't know the quest type (boss/collection) or the reward type

        name:             "название",            // table header for the quest name column
        availability:     "доступность",         // table header: how / when to obtain the scroll
        type:             "тип",                 // table header: type of quest (boss or collection)
        rewards:          "награды",             // table header: rewards that the quest gives
        boss_HP:          "здоровье<br />босса", // table header: starting health of boss
        boss_strength:    "сила<br />босса",     // table header: strength of boss

        length:           "длительность",
        difficulty:       "сложность",
        rating:           "рейтинг",
        release_date:     "дата выпуска",

        previous_part:    "пред. часть", // this text indicates that you can get the quest scroll when you complete the previous quest in the chain
        invite_to_party:  "пригласить кого-нибудь в команду", // used to indicate that you get the quest scroll when you invite someone to your party and they accept
        create_account:   "Создать учетную запись",            // this must be identical to Habitica's `createAccountReward` translated string
        finished:         "завершен", // indicates that the World Boss quest has finished and is no longer available
        only_during:      "только во время",  // used to indicate availability for quests that can be bought only during a specific Grand Gala
        XP_GP_only:       "только<br />опыт и золото", // the reward type for quests that give only XP and GP
        various:          "разное", // used to indicate the quest rewards when there's a variety of them
        etc:              "и др.", // added to the end of the quest's reward type when the quest gives multiple types
        one_of_each_food: "по одной ед. еды каждого вида", // a type of quest reward
        not_applicable:   "н/д", // an abbreviation meaning 'not applicable' (recommended to use a short word)

        weeks:            "нед.",  // 'weeks' or a shorter word for it (as short as possible is best)
        short:            "короткая",  // describes the length of time generally taken to complete a quest
        medium:           "средняя",   // as above
        long:             "длинная",   // as above

        very_hard:        "очень сложно", // describes how difficult a quest is in terms of having to be consistent with your Dailies
        hard:             "сложно",       // as above
        medium:           "средне",       // as above
        easy:             "легко",        // as above
        trivial:          "пустяк",       // as above

        million:          " млн.",
        or:               "или",
        or_earlier:       "или раньше",

        new_quest:        "Quest released this month", // used only within this page's instructions; will not appear on the wiki
        tables_to_edit:   "update the tables for", // used only within this page's instructions; will not appear on the wiki
        all_quests:       "All Quests", // subsection heading used only within this page's instructions
        quest_lines:      "Quest Lines", // subsection heading used only within this page's instructions
        easy_quests:      "Easy Quests", // subsection heading used only within this page's instructions
        medium_quests:    "Medium Quests", // subsection heading used only within this page's instructions
        hard_quests:      "Hard Quests", // subsection heading used only within this page's instructions
    }
};


//////////////////////////////////////////////////////////////////////
////   TRANSLATED REGULAR EXPRESSIONS                  ///////////////
////                                                   ///////////////
////   Add regular expressions that this page uses.    ///////////////
////                                                   ///////////////
//////////////////////////////////////////////////////////////////////
var regexpsForLanguage = { // XXX_LATER Should this specify that some strings must be identical to certain Habitica translations? If so, can we get that from the content data?
    'en': {
        pet:             / +\(Pet\)/i,
        mount:           / +\(Mount\)/i,
        gear:            / +\((Shield-hand Weapon|Armor|Headgear|Weapon|Shield-Hand Item)\)/i,
        egg:             /\(Egg\)/i,
        hatching_potion: /Hatching Potion/i,
        scroll:          / \(Scroll\)/i,
        quest_scroll:    / \(Quest Scroll\)/i,
        part:            /.*Part [0-9]: /i,
        part_url:        /.*Part_[0-9]:_/,
        food:            /\(Food\)/i,
    },
    'ru': {
        pet:             / +\([Пп]итомец\)/i,
        mount:           / +\([Сс]какун\)/i,
        gear:            / +\((оружие для защитной руки|оружие|для защитной руки|доспехи|головной убор|двуручное оружие)\)/i,
        egg:             /\([Яя]йцо\)/i,
        hatching_potion: /[Ии]нкубационый [Ээ]ликсир/i,
        scroll:          / \([Сс]виток\)/i,
        quest_scroll:    / \([Кк]вестовый [Сс]виток\)/i,
        part:            /.*[Чч]асть [0-9]: /i,
        part_url:        /.*[Чч]асть_[0-9]:_/,
        food:            /\([Ее]да\)/i,
    }
};


//////////////////////////////////////////////////////////////////////
////   TRANSLATED TEMPLATE NAMES                       ///////////////
////                                                   ///////////////
////   Add template names that specific wiki uses.     ///////////////
////                                                   ///////////////
//////////////////////////////////////////////////////////////////////
var templateNamesForLanguage = {
    'en': {
        all_quests:    "Quest Table All",
        quest_lines:   "Quest Table Quest Lines",
        easy_quests:   "Quest Table Easy",
        medium_quests: "Quest Table Medium",
        hard_quests:   "Quest Table Hard",
    },
    'ru': {
        all_quests:    "Таблица квестов",
        quest_lines:   "Таблица квестов/Квестовые линии",
        easy_quests:   "Таблица квестов/Легкие квесты",
        medium_quests: "Таблица квестов/Средние квесты",
        hard_quests:   "Таблица квестов/Сложные квесты",
    }
};


//////////////////////////////////////////////////////////////////////
////   TRANSLATED TEXT ORDER                           ///////////////
////                                                   ///////////////
////   Some data+text phrases in some languages need   ///////////////
////   to be reversed compared to English. Specify     ///////////////
////   them here.                                      ///////////////
////                                                   ///////////////
//////////////////////////////////////////////////////////////////////
var reverseTextForLanguage = {
    'level' : {
        'ru': true,
    },
};


var translationInstructions =    // Do not translate this into other languages. It's displayed only in the English version of the page.
    '<h3>Translations for Non-English Wikis</h3>' +
    '<p>If you would like to use this tool to create the tables for your own language\'s version of the wiki, add your language\'s code to the URL. For example, for the Russian ("ru") version you would use this URL:<br /><a href="https://oldgods.net/habitrpg/quest_table_creator.html?language=ru">https://oldgods.net/habitrpg/quest_table_creator.html?<strong>language=ru</strong></a><br />Habitica\'s official translations will then be used by this page. Some additional strings will need to be translated too (e.g., for the table headings) so contact Alys at lady_alys@oldgods.net to discuss that.</p>'
    // '<p>So far support exists for the languages below but others can be added!</p>' +
    // '<ul><li><a href="https://oldgods.net/habitrpg/quest_table_creator.html?language=ru">Russian</a></li></ul>'
    ;

//////////////////////////////////////////////////////////////////////
////   Determine Langauge from URL Parameter         /////////////////
//////////////////////////////////////////////////////////////////////
const urlParams = new URLSearchParams(window.location.search);

// Get the language specified in the URL if any:
const language = urlParams.get('language') || 'en';
// That language(will be used to choose the appropriate official
// Habitica translations when fetching/ the Habitica content data.

// If that language exists in the stringsForLanguage object, then
// this file contains additional translations specifically for this
// page (e.g., for table headers). Otherwise, English will be used
// for those strings.
const inPageLanguage = (stringsForLanguage[language]) ? language : 'en';

var wikiaBaseUrl = getString('WIKI_URL');


//////////////////////////////////////////////////////////////////////
////   RELEASE DATES FOR QUEST SCROLLS                 ///////////////
//////////////////////////////////////////////////////////////////////
var startOfTime = '2015-11';
var releaseDates = {
    'dilatory': startOfTime,
    'stressbeast': startOfTime,
    'burnout': startOfTime,
    'evilsanta': startOfTime,
    'evilsanta2': startOfTime,
    'gryphon': startOfTime,
    'hedgehog': startOfTime,
    'ghost_stag': startOfTime,
    'vice1': startOfTime,
    'vice2': startOfTime,
    'vice3': startOfTime,
    'egg': startOfTime,
    'rat': startOfTime,
    'octopus': startOfTime,
    'dilatory_derby': startOfTime,
    'atom1': startOfTime,
    'atom2': startOfTime,
    'atom3': startOfTime,
    'harpy': startOfTime,
    'rooster': startOfTime,
    'spider': startOfTime,
    'moonstone1': startOfTime,
    'moonstone2': startOfTime,
    'moonstone3': startOfTime,
    'goldenknight1': startOfTime,
    'goldenknight2': startOfTime,
    'goldenknight3': startOfTime,
    'basilist': startOfTime,
    'owl': startOfTime,
    'penguin': startOfTime,
    'trex': startOfTime,
    'trex_undead': startOfTime,
    'rock': startOfTime,
    'bunny': startOfTime,
    'slime': startOfTime,
    'sheep': startOfTime,
    'kraken': startOfTime,
    'whale': startOfTime,
    'dilatoryDistress1': startOfTime,
    'dilatoryDistress2': startOfTime,
    'dilatoryDistress3': startOfTime,
    'cheetah': startOfTime,
    'horse': startOfTime,
    'frog': startOfTime,
    'snake': startOfTime,
    'unicorn': '2015-12',
    'sabretooth' : '2016-01',
    'monkey' : '2016-02',
    'snail' : '2016-03',
    'falcon' : '2016-04',
    'bewilder' : '2016-04',
    'treeling' : '2016-05',
    'axolotl' : '2016-06',
    'turtle' : '2016-07',
    'armadillo' : '2016-08',
    'cow' : '2016-09',
    'beetle' : '2016-10',
    'taskwoodsTerror1' : '2016-10',
    'taskwoodsTerror2' : '2016-10',
    'taskwoodsTerror3' : '2016-10',
    'ferret' : '2016-11',
    'dustbunnies' : '2016-11',
    'moon1' : '2016-11',
    'moon2' : '2016-11',
    'moon3' : '2016-11',
    'sloth' : '2016-12',
    'triceratops' : '2017-01',
    'stoikalmCalamity1' : '2017-01',
    'stoikalmCalamity2' : '2017-01',
    'stoikalmCalamity3' : '2017-01',
    'guineapig' : '2017-02',
    'peacock' : '2017-03',
    'butterfly' : '2017-04',
    'mayhemMistiflying1' : '2017-04',
    'mayhemMistiflying2' : '2017-04',
    'mayhemMistiflying3' : '2017-04',
    'nudibranch' : '2017-06',
    'hippo' : '2017-08',
    'lostMasterclasser1' : '2017-10',
    'lostMasterclasser2' : '2017-10',
    'lostMasterclasser3' : '2017-10',
    'lostMasterclasser4' : '2017-10',
    'yarn' : '2017-11',
    'pterodactyl' : '2018-01',
    'badger' : '2018-02',
    'dysheartener' : '2018-02',
    'squirrel' : '2018-04',
    'seaserpent' : '2018-07',
    'kangaroo' : '2018-08',
    'alligator' : '2018-10',
    'velociraptor' : '2019-01',
    'bronze' : '2019-05',
    'dolphin' : '2019-07',
    'silver' : '2019-08',
};
// get the current month's date in case the latest quest
// hasn't been added above yet:
var d = new Date();
var month = d.getMonth() + 1;
var thisMonth = d.getFullYear() + '-' + ((month < 10) ? '0' : '') + month;


//////////////////////////////////////////////////////////////////////
////   SCROLL IMAGE FILE NAMES FOR EACH QUEST          ///////////////
////                                                   ///////////////
////   Add new entries here (in any order) when a new  ///////////////
////   quest becomes available.                        ///////////////
////   This is necessary only if the wiki image links  ///////////////
////   for the quest scroll do not match the file      ///////////////
////   names from Habitica.                            ///////////////
////                                                   ///////////////
////   DO NOT PUT SPACES IN THESE FILE NAMES!          ///////////////
//////////////////////////////////////////////////////////////////////
var images = {
    'evilsanta':    'Inventory_quest_scroll_evilsanta.png',
    'burnout':      'image_not_applicable',
    'stressbeast':  'image_not_applicable',
    'dilatory':     'image_not_applicable',
    'bewilder':     'image_not_applicable',
    'dysheartener': 'image_not_applicable',
};

//////////////////////////////////////////////////////////////////////
////   AVAILABILITY TEXT FOR **SOME** QUESTS           ///////////////
////                                                   ///////////////
////   Add new entries here (in any order) when        ///////////////
////   a new quest becomes available if and only if    ///////////////
////   its availability is not the standard            ///////////////
////   "permanent".                                    ///////////////
//////////////////////////////////////////////////////////////////////
var questAvailability = {
    'basilist':     getString('invite_to_party'),
    'egg':          getString('only_during') + ' ' + make_url('Spring Fling'), // XXX finish translation - depending on the language, there may be a declension of the word
    'evilsanta':    getString('only_during') + ' ' + make_url('Winter Wonderland'), // XXX finish translation
    'evilsanta2':   getString('only_during') + ' ' + make_url('Winter Wonderland'), // XXX finish translation
    'burnout':      getString('finished'),
    'stressbeast':  getString('finished'),
    'dilatory':     getString('finished'),
    'bewilder':     getString('finished'),
    'dysheartener': getString('finished'),
};

//////////////////////////////////////////////////////////////////////
////   WIKI LINKS FOR **SOME** QUESTS                  ///////////////
////                                                   ///////////////
////   Add new entries here (in any order) when        ///////////////
////   a new quest becomes available.                  ///////////////
////   This is necessary only if the wiki page         ///////////////
////   filename does not match the filename that can   ///////////////
////   be created automatically from the quest's name. ///////////////
////                                                   ///////////////
////   DO NOT PUT SPACES IN THESE LINKS!               ///////////////
//////////////////////////////////////////////////////////////////////
var questPageUrls = {  // XXX_NOW need translate
    'atom1' : 'Dish_Disaster',
    'evilsanta2' : 'Find_the_Cub',
};

//////////////////////////////////////////////////////////////////////
////   LINKS FOR REWARDS (GEAR, ETC)                   ///////////////
////                                                   ///////////////
////   Add new entries here (in any order) when        ///////////////
////   a quest rewards you with equipment AND when     ///////////////
////   that equipment has its own wiki page.           ///////////////
////                                                   ///////////////
////   DO NOT PUT SPACES IN THESE LINKS!               ///////////////
//////////////////////////////////////////////////////////////////////
var rewardPageUrls = {  // XXX_NOW need translate
    'shield_special_goldenknight': 'Mustaine%27s_Milestone_Mashing_Morningstar',
    'weapon_special_2': 'Stephen_Weber%27s_Shaft_of_the_Dragon',
    'head_special_2': 'Nameless_Helm',
    'armor_special_2': 'Jean_Chalard%27s_Noble_Tunic',
};

//////////////////////////////////////////////////////////////////////
////   Global Variables                              /////////////////
//////////////////////////////////////////////////////////////////////
var content; // holds site-wide content (gear names and stats, quests, etc)
var serverUrl = 'https://habitica.com:443/api/v3';

//////////////////////////////////////////////////////////////////////
////   Data Fetch Function   /////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
fetchData();
function fetchData() {
    $('#loading .good').show();
    $('#loading .bad' ).hide();

    // fetch the site-wide content (quest names and stats, etc):
    $.ajax({
        url: serverUrl + '/content',
        type: 'GET',
        data: { language: language },
        dataType: 'json',
        cache: true,
        success: fetchContentSuccess,
        error: fetchFailure
    });

    function fetchFailure() {
        $('#loading .good').hide();
        $('#loading .bad' ).show();
    }
    function fetchContentSuccess(data) {
        content = data.data;
        parseData();
    }
}

function parseData() {
    var allQuests = content.quests;
    var allQuestsStringified = JSON.stringify(allQuests, null, 4);

    // Get quest IDs and sort them in the desired display order
    // (world bosses at end because of least interest):
    var questIds    = [];
    var questIdsEnd = [];
    for (var questId in allQuests) {
        var quest = allQuests[questId];
        if (quest.category && quest.category === 'world') {
            questIdsEnd.push(questId);
        }
        else {
            questIds.push(questId);
        }
    }
    questIds = questIds.concat(questIdsEnd);

    // Find the first quest in each quest line:
    var questLineStartIds = {};
    for (var questId in allQuests) {
        var quest = allQuests[questId];
        if (quest.previous) {
            questLineStartIds[quest.previous] = true;
        }
    }

    var warnings = '';

    var headers = [ ' class="unfilterable" | ' + getString('name'),
                    ' class="unfilterable" | ' + getString('scroll'),
                    ' class="unfilterable" | ' + getString('availability'),
                    ' class="unsortable"   | ' + getString('type'),
                    ' class="unfilterable" | ' + getString('rewards'),
                    ' class="unfilterable" | ' + getString('GP'),
                    ' class="unfilterable" | ' + getString('XP'),
                    ' class="unfilterable" | ' + getString('boss_HP'),
                    ' class="unfilterable" | ' + getString('boss_strength')
                  ];

    var headersHtml = [ getString('name'), getString('scroll'), getString('availability'), getString('type'), getString('rewards'), getString('GP'), getString('XP'), getString('boss_HP'), getString('boss_strength') ];
    headersHtml.push('<em>' + getString('length') + '</em>', '<em>' + getString('difficulty') + '</em>', '<em>' + getString('rating') + '</em>', '<em>' + getString('release_date') + '</em>');

    // table row for each quest:
    var releaseDateNeeded = '';
    var tableRows    = { 'all':        [],
                         'easy':       [],
                         'medium':     [],
                         'hard':       [],
                         'questLines': [],
                       };
    var tableRowsHtml    = [];
    var devData = '';
    var latestQuestUpdatesNeeded = '';
    var allQuestRewardsBugFixNormal = '';
    var allQuestRewardsBugFixSpecial = '';
    for (var index = 0; index < questIds.length; index++) {
        var questId = questIds[index];
        var quest = allQuests[questId];
        // devData += "    '" + questId + "': startOfTime,\n";
        var row     = [];

        var questRewardsBugFixNormal = '';
        var questRewardsBugFixSpecial = '';
        questRewardsBugFixNormal += '"achievements.quests.' + questId + '":1, ';

        var questName = quest.text;
        if (language === 'en') {
            questName = questName.replace(/^The /, ''); // XXX_LATER replicate for other languages? Might be a can of worms, especially for gendered languages.
        }
        row.push([ make_url(quest.text, {'url': questPageUrls[questId] || ''} ),
                   'data-sort-value="' + questName + '"' ]);

        row.push([ make_image(images[questId] ||
                             'Inventory_quest_scroll_' + questId + '.png',
                             questId),
                  'data-sort-value="' + questId + '"' ]);

        var availability = '';
        var displayLevelRestriction = false;
        if (quest.category && quest.category === 'unlockable') {
            if (quest.unlockCondition && quest.unlockCondition.text &&
                quest.unlockCondition.text === getString('create_account')
               ) {
                availability = quest.unlockCondition.text.toLowerCase();
            }
            else if (quest.unlockCondition && quest.unlockCondition.incentiveThreshold) {
                // XXX_LATER TODO: Is it possible to add pluralization? May be possible if pluralisation rules in various languages won't make it too hard.
                //       (e.g., 1 вход, 22 входа, 7 входов)
                availability = make_url(quest.unlockCondition.incentiveThreshold + ' ' + getString('checkins'), {'url' : getString('checkins_page')} );
            }
            else if (quest.previous) {
                availability = getString('previous_part');
                displayLevelRestriction = quest.lvl; // true
            }
            else if (quest.lvl) {
                availability = (reverseTextForLanguage['level'][inPageLanguage])
                             ? quest.lvl + ' ' + getString('level')
                             : getString('level') + ' ' + quest.lvl;
            }
        }
        if (quest.unlockCondition && quest.unlockCondition.condition &&
            quest.unlockCondition.condition === 'party invite'
           ) {
            delete quest.value; // Habitica's config lies
        }
        var cost = (quest.goldValue) ? quest.goldValue + ' ' + getString('GP') :
                   (quest.value)     ? quest.value + ' ' + getString('gems')
                                     : '';
        if (cost) {
            if (availability) {
                availability += ' ' + getString('or') + '<br />';
            }
            availability += cost;
        }
        if (questAvailability[questId]) {
            if (availability) {
                availability += '<br />';
            }
            availability += questAvailability[questId];
        }
        if (displayLevelRestriction) {
            availability += '<br />(';
            availability += (reverseTextForLanguage['level'][inPageLanguage])
                         ? quest.lvl + ' ' + getString('level')
                         : getString('level') + ' ' + quest.lvl;
            availability += ')';
        }
        row.push(availability);

        var objectiveType =
            (quest.category && quest.category === 'world') ? getString('world_boss') :
            (quest.collect) ? getString('collection') :
            (quest.boss)    ? getString('boss') :
                              getString('unknown');
        row.push(objectiveType);

        var droppedGP = quest.drop.gp || 0;
        var droppedXP = quest.drop.exp || 0;
        delete quest.drop.gp;
        delete quest.drop.exp;
        var XPandGPonly = jQuery.isEmptyObject(quest.drop);
        questRewardsBugFixNormal += '"stats.gp":' + droppedGP + ', "stats.exp":' + droppedXP + ', ';

        delete quest.drop.unlock;

        var items = {};
        if (quest.drop.items) {
            for (var i in quest.drop.items) {
                var obj = quest.drop.items[i];
                if (!items[obj.type]) {
                    items[obj.type] = {}; // e.g., "eggs", "gear"
                }
                if (!items[obj.type][obj.key]) {
                    items[obj.type][obj.key] = {}; // e.g., Potatoe
                }
                items[obj.type][obj.key]['text'] = obj.text; // e.g., Potato
                if (!items[obj.type][obj.key]['count']) {
                    items[obj.type][obj.key]['count'] = 0;
                }
                items[obj.type][obj.key]['count']++;
                delete obj.type;
                delete obj.key;
                delete obj.text;
                delete obj.onlyOwner;
                if (Object.keys(obj).length) {
                    console.log('"obj" object has other contents:');
                    console.log(obj);
                }
            }
        }
        delete quest.drop.items;
        if (Object.keys(quest.drop).length) {
            console.log('"quest.drop" object has other contents:');
            console.log(quest.drop);
        }

        var petName   = '';
        var mountName = '';
        var equipment = [];
        var other     = [];
        for (var type in items) {
            if (type === 'food' && quest.category === 'world') {
                other.push(getString('one_of_each_food')); // ASSUME this happens for each world quest
            }
            else {
                for (var key in items[type]) {
                    var text = items[type][key]['text'];
                    var bugFixValue = 'UNKNOWN';
                    if (type === 'pets') {
                        // ASSUME this key doesn't appear in rewardPageUrls
                        // ASSUME there's no more than one pet
                        petName = text.replace(getRegexp('pet'), '');
                        bugFixValue = 5;
                    }
                    else if (type === 'mounts') {
                        // ASSUME this key doesn't appear in rewardPageUrls
                        // ASSUME there's no more than one mount
                        mountName = text.replace(getRegexp('mount'), '');
                        bugFixValue = 'true'; // string!
                    }
                    else {
                        if (type === 'gear') {
                            text = text.replace(getRegexp('gear'), '');
                            bugFixValue = 'true'; // string!
                        }
                        else if (type === 'eggs') {
                            text = text.replace(getRegexp('egg'), '('+ getString('egg') +')');
                            bugFixValue = items[type][key]['count'];
                        }
                        else if (type === 'hatchingPotions') {
                            text = text.replace(getRegexp('hatching_potion'), getString('hatching_potion'));
                            bugFixValue = items[type][key]['count'];
                        }
                        else if (type === 'food') {
                            text = text.replace(getRegexp('food'), '('+ getString('food') +')');
                            bugFixValue = items[type][key]['count'];
							// XXX from Jazzis in GitHub: "By the way, such a replacement with a translatable regular expression and a translatable string is not very obvious. I mean, it are set separately, and it is not clear that this the string will probably be involved in the replacement."
                        }
                        else {
                            bugFixValue = items[type][key]['count'];
                        }
                        if (rewardPageUrls[key]) {
                            text = make_url(text, {'url': rewardPageUrls[key]} );
                        }
                        if (items[type][key]['count'] > 1) {
                            text += ' x ' + items[type][key]['count'];
                        }
                        if (type === 'gear') {
                            equipment.push(text);
                        }
                        else {
                            other.push(text);
                        }
                    }
                    if (type === 'gear') {
                        questRewardsBugFixSpecial += '"items.' + type + '.owned.' + key + '":' + bugFixValue + ', ';
                    }
                    else {
                        questRewardsBugFixNormal += '"items.' + type + '.' + key + '":' + bugFixValue + ', ';
                    }
                }
            }
        }

        if (petName && mountName && petName === mountName) {
            var pets = petName + ' (' + getString('pet_and_mount') + ')';
            other.unshift(pets);
        }
        else {
            if (petName) {
                other.unshift(petName + ' (' + getString('pet') + ')');
            }
            if (mountName) {
                other.unshift(mountName + ' (' + getString('mount') + ')');
            }
        }
        var rewardItems = equipment.concat(other);

        var specialRewardType = getString('unknown');
        var etcPossible = false;
        if (XPandGPonly) {
            specialRewardType = getString('XP_GP_only');
        }
        if (items['gear']) {
            specialRewardType = getString('equipment');
            etcPossible = true;
            delete items['gear'];
        }
        if (items['quests']) {
            specialRewardType = getString('scroll');
            etcPossible = true;
            delete items['quests'];
        }
        if (etcPossible && Object.keys(items).length) {
            specialRewardType += ', ' + getString('etc');
        }
        var rewardType =
            (!quest.category)                     ? specialRewardType            :
            (quest.category === 'world')          ? getString('various')         :
            (quest.category === 'gold')           ? specialRewardType            :
            (quest.category === 'unlockable')     ? specialRewardType            :
            (quest.category === 'hatchingPotion') ? getString('hatching_potion') : // XXX_LATER make less redundant: "hatching potion: Silver hatching potion x 3"
                                                    getString(quest.category); // e.g., pet

        // add list of rewards to reward type, with some abbreviations:
        var itemsString = rewardItems.join(';<br />');
        if (rewardType === getString('scroll')) {
            itemsString = itemsString.replace(getRegexp('scroll'), '');
            itemsString = itemsString.replace(getRegexp('quest_scroll'), '');
            itemsString = itemsString.replace(getRegexp('part'), '');
        }

        if (itemsString) {
            rewardType += ':<br />' + itemsString;
        }

        row.push(rewardType);

        row.push(droppedGP);
        row.push(droppedXP);

        var bossHP     = getString('not_applicable');
        var bossHPSort = 0;
        var bossStr    = getString('not_applicable');
        var bossRage   = '';
        var questLength         = getString('not_applicable');
        var questLengthDetailed = getString('not_applicable');
        var questDifficulty     = getString('not_applicable');
        if (quest.boss) {
            bossHP     = quest.boss.hp || 0;
            bossHPSort = bossHP;
            bossStr  = quest.boss.str  || 0;
            bossRage = (quest.boss.rage && quest.boss.rage.value) ? +quest.boss.rage.value : 0;
            if ((!quest.category || quest.category !== 'world')) {
                if (bossHP > 999) {
                    questLength = '3. ' + getString('long');
                }
                else if (bossHP > 499) {
                    questLength = '2. ' + getString('medium');
                }
                else {
                    questLength = '1. ' + getString('short');
                }

                if (bossHP > 1200) {
                    questLengthDetailed = '> 4 ' + getString('weeks');
                }
                else if (bossHP > 1000) {
                    questLengthDetailed = '~ 4 ' + getString('weeks');
                }
                else if (bossHP > 900) {
                    questLengthDetailed = '3-4 ' + getString('weeks');
                }
                else if (bossHP > 799) {
                    questLengthDetailed = '~ 3 ' + getString('weeks');
                }
                else if (bossHP > 500) {
                    questLengthDetailed = '2-3 ' + getString('weeks');
                }
                else if (bossHP > 400) {
                    questLengthDetailed = '~ 2 ' + getString('weeks');
                }
                else if (bossHP > 300) {
                    questLengthDetailed = '< 2 ' + getString('weeks');
                }
                else {
                    questLengthDetailed = '~ 1 ' + getString('weeks');
                }

                if (bossStr > 2.5) {
                    questDifficulty = '5. ' + getString('very_hard');
                }
                else if (bossStr === 2.5) {
                    questDifficulty = '4. ' + getString('hard');
                }
                else if (bossStr >= 2) {
                    questDifficulty = '3. ' + getString('medium');
                }
                else if (bossStr >= 1.5) {
                    questDifficulty = '2. ' + getString('easy');
                }
                else {
                    questDifficulty = '1. ' + getString('trivial');
                }
            }

            var divisor = 1000 * 1000;
            if (bossHP > divisor) {
                bossHP = bossHP / divisor;
                bossHP += getString('million');
            }
            if (bossRage && bossRage > divisor/10) {
                bossRage = bossRage / divisor;
                bossRage += getString('million');
            }
        }
        else if (quest.collect) {
            var count = 0;
            for (var i in quest.collect) {
                if (quest.collect[i].count) {
                    count += quest.collect[i].count;
                }
            }

            if (count > 300) {
                questDifficulty = '5. ' + getString('very_hard');
                questLength = '3. ' + getString('long');
                questLengthDetailed = '';
            }
            else if (count > 100) {
                questDifficulty = '4. ' + getString('hard');
                questLength = '3. ' + getString('long');
                questLengthDetailed = '';
            }
            else if (count > 30) {
                questDifficulty = '3. ' + getString('medium');
                questLength = '2. ' + getString('medium');
                questLengthDetailed = '';
            }
            else {
                questDifficulty = '2. ' + getString('easy');
                questLength = '1. ' + getString('short');
                questLengthDetailed = '';
            }
        }

        var rating = getString('unknown');
        if (quest.category && quest.category === 'world') {
            rating = '4. ' + getString('not_applicable');
        }
        else if ((questDifficulty === '1. ' + getString('trivial') ||
              questDifficulty === '2. ' + getString('easy')) && questLength === '1. ' + getString('short')
            ) {
            rating = '1. ' + getString('easy');
        }
        else if ( questDifficulty >= '4. ' + getString('hard') ||
                 (questDifficulty === '3. ' + getString('medium') && questLength === '3. ' + getString('long'))
                ) {
            rating = '3. ' + getString('hard');
        }
        else {
            rating = '2. ' + getString('medium');
        }

        row.push([ bossHP + ((bossRage) ? '<br />' + getString('rage') + ':'+bossRage : ''),
                   'data-sort-value="' + bossHPSort + '"' ]);
        row.push(bossStr);

        var myRegexpLink  = /(.*)\[(\S+) +([^\]]+)\](.*)/g;            // '[' + url + ' ' + text + ']'; // XXX translate?
        var myRegexpImage = /(.*)\[\[File:([^\|]+)\|[^\]]+\]\](.*)/g;  // '[[File:' + image + '|' + hoverText + ']]'; // XXX translate?

        // So far, row contains the table cells for a Wikia table.
        // We now create an HTML version, and then add more fields to that.
        var rowHtml = [];
        for (var i in row) {
            var valueObj = row[i];
            var value  = '';
            if (Object.prototype.toString.call(valueObj) === '[object Array]') {
                value  = valueObj[0];
                // ignore second element which is a wikia table config string
            }
            else {
                value = valueObj;
            }

            // replace Wikia links and images with HTML versions (we ASSUME there's at most ONE link and ONE image per table cell):
            var match = myRegexpLink.exec(value);
            if (match) {
                value = match[1] + '<a href="' + match[2] + '">' + match[3] + '</a>' + match[4];
            }
            var match = myRegexpImage.exec(value);
            if (match) {
                value = match[1] + '<img src="' + 'fake_broken_image' + '" />' + match[3]; // no image because it won't work anyway
                value += '<br />' + questId;
            }

            rowHtml.push(value);
        }

        if (false) { // This is disabled for now because it prevents the data-sort-value field appearing in the output. XXX_LATER keep working on this. Maybe improve the original code to make the converting back and forth not needed. Get details about why internal links are better for this situation.
        // It would be better if the wiki pages had internal links, rather than external ones that link to wiki pages.
        // Therefore, after forming the row for the HTML table, we make the links internal again.
        var myRegexpLink = /(.*)\[((http|https)?:\/\/)?(\w+\.fandom\.com)(\/\w+)?(\/wiki)?\/(.+?)\s(.+)\](.*)/g;
        var match = myRegexpLink.exec(row[0]);  // table header: name
        if (match) {
            if (match[7] === match[8].replace(/ /g, '_')) {
                row[0] = '[[' + match[8] + ']]';
            }
            else {
                row[0] = '[[' + match[7] + '|' + match[8] + ']]';
            }
        }
        var myRegexpLink = /(.*)\[((http|https)?:\/\/)?(\w+\.fandom\.com)(\/\w+)?(\/wiki)?\/(.+?)\s(.+)\](.*)/g;
        var match = myRegexpLink.exec(row[2]);  // table header: availability
        if (match) {
            if (match[7] === match[8].replace(/ /g, '_')) {
                row[2] = match[1] + '[[' + match[8] + ']]' + match[9];
            }
            else {
                row[2] = match[1] + '[[' + match[7] + '|' + match[8] + ']]' + match[9];
            }
        }
        var myRegexpLink = /(.*)\[((http|https)?:\/\/)?(\w+\.fandom\.com)(\/\w+)?(\/wiki)?\/(.+?)\s(.+)\](.*)/g;
        var match = myRegexpLink.exec(row[4]);  // table header: rewards
        if (match) {
            if (match[7] === match[8].replace(/ /g, '_')) {
                row[4] = match[1] + '[[' + match[8] + ']]' + match[9];
            }
            else {
                row[4] = match[1] + '[[' + match[7] + '|' + match[8] + ']]' + match[9];
            }
        }
        }

        rowHtml.push(questLength + ((questLengthDetailed) ?
                    '<br />(' + questLengthDetailed + ')' : ''));
        rowHtml.push(questDifficulty);
        rowHtml.push(rating);

        var releaseDate       = '';
        var releaseDatePretty = '';
        if (! releaseDates[questId]) {
            releaseDateNeeded += "'" + questId +"' : '"+ thisMonth + "',<br />";
        }
        releaseDate = releaseDates[questId] || thisMonth;
        if (releaseDate === startOfTime) {
            releaseDatePretty = releaseDate + '<br />'+ getString('or_earlier');
        }
        else {
            releaseDatePretty = releaseDate;
        }
        rowHtml.push(releaseDatePretty);

        // We now have the `row` array which contains Wikia code for
        // this quest, and the `rowHtml` array which contain HTML code.
        // We save the `row` array into one or more collections of
        // quests, depending on the parameters of this quest.
        // For the HTML table, there is only one collection.

        if (releaseDate === thisMonth) {
            latestQuestUpdatesNeeded += getString('new_quest') + ': <strong>' + questName + '</strong> -- ' +
                                        getString('tables_to_edit') + ' ' + getString('all_quests');
        }

        if (quest.previous || questId.match(/evilsanta/) || questLineStartIds[questId]) {
            tableRows.questLines.push( convertRow('wikia', row) );
            if (releaseDate === thisMonth) { latestQuestUpdatesNeeded += ', ' + getString('quest_lines'); }
        }

        tableRowsHtml.push(rowHtml);
        tableRows.all.push( convertRow('wikia', row) );

        if (rating === '1. ' + getString('easy')) {
            tableRows.easy.push( convertRow('wikia', row) );
            if (releaseDate === thisMonth) { latestQuestUpdatesNeeded += ', ' + getString('easy_quests'); }
        }
        else if (rating === '2. ' + getString('medium')) {
            tableRows.medium.push( convertRow('wikia', row) );
            if (releaseDate === thisMonth) { latestQuestUpdatesNeeded += ', ' + getString('medium_quests'); }
        }
        else if (rating === '3. ' + getString('hard')) {
            tableRows.hard.push( convertRow('wikia', row) );
            if (releaseDate === thisMonth) { latestQuestUpdatesNeeded += ', ' + getString('hard_quests'); }
        }
        if (releaseDate === thisMonth) {
            latestQuestUpdatesNeeded += ".<br />";
            allQuestRewardsBugFixNormal += '// ' + questRewardsBugFixNormal + '  // ' + questId + ' : ' + quest.text;
            if (questRewardsBugFixSpecial) {
                allQuestRewardsBugFixNormal += '  // ALSO SPECIAL REWARD';
                allQuestRewardsBugFixSpecial += '// ' + questRewardsBugFixSpecial + '  // ' + questId + ' : ' + quest.text;
                allQuestRewardsBugFixSpecial += '<br />';
            }
            allQuestRewardsBugFixNormal += '<br />';
        }
    }

    var questTableHeader = '' +
'\n{| class="filterable sortable" border="1" cellpadding="2" cellspacing="0" style="width: 100%; text-align: center; background: #F2F2F2; border:5px solid #F2F2F2;"' +
'\n|- style="background: #284C6D; color: #FFFFFF; white-space: nowrap;"' +
    convertRow('wikia', headers, 'th');

    var questTableFooter = '' +
'\n|- class="sortbottom"' +
'\n| colspan="10" style="height: 0px; border-bottom: 3px solid #284C6D;"|' +
'\n|}\n';


    // create HTML table showing production data and development data:
    var columns = [];
    for (var i in headersHtml) {
        columns.push({'title': headersHtml[i]});
    }
    $(document).ready(function() {
        $('#theTable').DataTable( {
            'data': tableRowsHtml,
            'columns': columns,
            'bPaginate': false,
            'aaSorting': [], // no default sorting
        } );
    } );

    var htmlEnd = '';
    if (releaseDateNeeded) {
        htmlEnd  += '<p>NOTES FOR ALYS:<br />Need release date:<br />' + releaseDateNeeded +
                    // 'Rewards:<br />' + allQuestRewardsBugFixSpecial + allQuestRewardsBugFixNormal +
                    '</p>';

    }
    if (warnings) htmlEnd += '<p>WARNING:<br />' + warnings + '</p>';
    if (false) { // FOR TESTING
        htmlEnd += "<p>The material below here is Habitica's JSON data that" +
                " was used to make the wikia code above. You can ignore it" +
                " unless you are interested in it. You do not need to" +
                " copy it to the wiki.</p>" +
                "<pre>" + allQuestsStringified + "</pre>";
    }
    if (devData) {
        htmlEnd += '<pre>' + devData + '</pre>';
    }


    //////////////////////////////////////////////////////////////////////
    ////   Display the HTML    ///////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    // XXX_LATER translate all the instructions?

    // XXX_NOW use wikiaBaseUrl in text below or make_url
    var htmlStart = '';
    ////// var htmlStart = '<p>This page outputs the wikia code for creating tables'
        ////// + ' on the <a href="http://habitica.fandom.com/">Habitica wiki</a>.'
        ////// + ' One table is for the [XXX finish this ... quest table pages ] '
        // + ' <a href="http://habitica.fandom.com/wiki/Equipment_Table">'
        // + 'Equipment Table</a> page, and the other is for the'
        // + ' <a href="http://habitica.fandom.com/wiki/Enchanted_Armoire">'
        // + 'Enchanted Armoire</a> page.</p>'
        // + '<p>Copy everything inside each textarea below and paste it '
        // + 'into the appropriate template pages: <a href="'
        // + 'http://habitica.fandom.com/wiki/Template:Equipment_Table_Code'
        // + '">Template:Equipment_Table_Code</a> and <a href="'
        // + 'http://habitica.fandom.com/wiki/Template:Enchanted_Armoire_Table_Code'
        // + '">Template:Enchanted_Armoire_Code</a>.'
        ////// + '</p>';

    $('#loading .good').hide();
    $('#output').html(htmlStart +
        '<p>' + latestQuestUpdatesNeeded + '</p>' +
        '<h2>Notes:</h2>' +
        '<ul>' +
        '<li>Post to the Wizards of the Wiki guild if you have suggestions for improving this.</li>' +

        '<li>The <strong>length</strong>, <strong>difficulty</strong>, and <strong>rating</strong> columns do not appear on the wiki but are included in the table below to help us categorise the quests into pages.</li>' +
        '<li>The <strong>release date</strong> column does not appear on the wiki. It is used here only to help us work out which pages need to be updated when a new quest is released, and so exact release dates for most of the quests are not included.</li>' +

        '<li>Quest scroll images will always look broken in the HTML table here, but will work on the wiki.</li>' +
        '<li>Sorting won\'t always work correctly in the HTML table here, but will work on the wiki.</li>' +

        '<li>Any information pulled straight from Habitica should be correct. Any information that Alys had to write code to calculate might be wrong. Any bugs can be easily fixed.</li>' +

        '</ul>' +

        '<h3>Length, Difficulty, and Rating</h3>' +
        '<ul>' +
        '<li>For a boss quest, if the boss\'s HP is 1000 or above, it\'s "long"; 500 and up is "medium"; others are "short".  If the boss strength is greater than 2.5, it\'s "very hard"; exactly 2.5 is "hard"; 2 or above is "medium"; 1.5 or above is "easy"; others are "trivial".</li>' +
        '<li>For a collection quest, needing more than 300 items is "very hard" and "long"; more than 100 is "hard" and "long"; more than 30 is "medium" for both; others are "easy" and "short".</li>' +
        '<li>The rating is a merge of the length and difficulty. Any quest with a trivial / easy difficulty AND a short length is rated "easy". Any quest with a hard difficulty or a long quest with a medium difficulty is rated "hard". The others are rated "medium".</li>' +
        '</ul>' +

        ((inPageLanguage === 'en') ? translationInstructions : '') +

        '<h2>' + getString('all_quests') + '</h2>' +
        '<p>This textarea contains code to produce a Wikia table showing all quests. Paste this code into this template: ' +
        make_url('all_quests', {template:true, html:true}) +
        '</p><textarea rows="5" cols="100" wrap="off">' +
        questTableHeader +
        tableRows.all.join("") +
        questTableFooter +
        '</textarea>' +

        '<h2>' + getString('quest_lines') + '</h2>' +
        '<p>This textarea contains code to produce a Wikia table showing only quests that are in quest lines. Paste this code into this template: ' +
        make_url('quest_lines', {template:true, html:true}) +
        '</p><textarea rows="5" cols="100" wrap="off">' +
        questTableHeader +
        tableRows.questLines.join("") +
        questTableFooter +
        '</textarea>' +

        '<h2>' + getString('easy_quests') + '</h2>' +
        '<p>This textarea contains code to produce a Wikia table showing only easy quests. Paste this code into this template: ' +
        make_url('easy_quests', {template:true, html:true}) +
        '</p><textarea rows="5" cols="100" wrap="off">' +
        questTableHeader +
        tableRows.easy.join("") +
        questTableFooter +
        '</textarea>' +

        '<h2>' + getString('medium_quests') + '</h2>' +
        '<p>This textarea contains code to produce a Wikia table showing only medium quests. Paste this code into this template: ' +
        make_url('medium_quests', {template:true, html:true}) +
        '</p><textarea rows="5" cols="100" wrap="off">' +
        questTableHeader +
        tableRows.medium.join("") +
        questTableFooter +
        '</textarea>' +

        '<h2>' + getString('hard_quests') + '</h2>' +
        '<p>This textarea contains code to produce a Wikia table showing only hard quests. Paste this code into this template: ' +
        make_url('hard_quests', {template:true, html:true}) +
        '</p><textarea rows="5" cols="100" wrap="off">' +
        questTableHeader +
        tableRows.hard.join("") +
        questTableFooter +
        '</textarea>' +

        '<p>This is an HTML version of the table that shows all quests (but with some differences to the tables you\'ll find on the wiki):</p>' +
        htmlEnd
    );
}


function convertRow(format, rowArray, cellType) {
    // format is 'html' or 'wikia'
    var html = (format === 'html') ? true : false;
    cellType = cellType || 'td'; // 'th' can be specified manually
    if (!html) {
        cellType = (cellType === 'td') ? '|' : '!'; // Wikia versions of td and th
    }

    var row = (html) ? '<tr>' : ((cellType === '|') ? '\n|-' : '');
    for (var i in rowArray) {
        var valueObj = rowArray[i];
        var value  = '';
        var config = '';
        if (Object.prototype.toString.call(valueObj) === '[object Array]') {
            value  = valueObj[0];
            config = valueObj[1] + ' | ';
        }
        else {
            value = valueObj;
        }

        row += (html) ?
            '<'  + cellType + '>' :
            '\n' + cellType;
        row += config + value;
        row += (html) ?
            '</' + cellType + '>' :
            '';
    }
    row += (html) ? '</tr>\n' : '';
    return row;
}


function make_url(visibleText, options = {}) { // XXX_LATER manually check that all the Template links are correct, including for Russian
    var linkText = visibleText;
    var url = options['url'] || '';
    if (options['template']) {
		visibleText = getTemplateName(visibleText);
		linkText = 'Template:' + visibleText;
    }
    if (!url) {
        url = linkText.replace(/ /g, '_');
        url = url.replace(getRegexp('part_url'), ''); // e.g., convert Terror_in_the_Taskwoods,_Part_3:_Jacko_of_the_Lantern to Jacko_of_the_Lantern
    }
    if (url.indexOf('://') === -1) {
        url = wikiaBaseUrl + url;
    }
    if (options['html']) { // XXX look into using this more?
        return '<a href="' + url + '">' + visibleText + '</a>';
    }
    else {
        return '[' + url + ' ' + visibleText + ']'; // XXX maybe change to this where possible: '[[' + url + '|' + text + ']]';
    }
}


function make_image(image, hoverText) {
    if (!image) {
        return '';
    }
    if (image === 'image_not_applicable') {
        return getString('not_applicable');
    }
    hoverText = hoverText || '';
    return '[[File:' + image + '|' + hoverText + ']]';
    // return [ '<img src="null" />',
             // '[[File:' + image + ']]' ];
    // return (html) ? '<img src="null" />' :
                    // '[[File:' + image + ']]';
}


function getString(key) {
    if (stringsForLanguage[inPageLanguage] && stringsForLanguage[inPageLanguage][key]) {
        return stringsForLanguage[inPageLanguage][key];
    }
    else if (stringsForLanguage['en'][key]) {
        return stringsForLanguage['en'][key];
    }
    else {
        return key;
    }
}

function getRegexp(key) {
    if (regexpsForLanguage[inPageLanguage] && regexpsForLanguage[inPageLanguage][key]) {
        return regexpsForLanguage[inPageLanguage][key];
    }
    else if (regexpsForLanguage['en'][key]) {
        return regexpsForLanguage['en'][key];
    }
    else {
        return key;
    }
}

function getTemplateName(key) {
    if (templateNamesForLanguage[inPageLanguage] && templateNamesForLanguage[inPageLanguage][key]) {
        return templateNamesForLanguage[inPageLanguage][key];
    }
    else if (templateNamesForLanguage['en'][key]) {
        return templateNamesForLanguage['en'][key];
    }
    else {
        return key;
    }
}


});
</script>

<style>
/*********************************************************************
****   Page-wide   ***************************************************
*********************************************************************/
body {
    font-family: Helvetica, Arial, sans-serif;
    font-size: 14px;
    background-color: rgb(173, 208, 215);
}
#innerBody {
    margin: 20px;
    padding: 5px 20px 30px 20px;
    background-color: rgb(242, 242, 230);
}
#loading {
    margin-right: 30px;
    margin-left: 30px;
    color: orange;
    font-size: 1.5em;
    font-weight: bold;
}
#loading ul {
    font-size: 0.8em;
}
#loading ul a {
    color: orange;
}


hr {
    width: 95%;
}
hr.padded {
    margin-top:    1em;
    margin-bottom: 2em;
}

.show {
    display: block;
}
.hide {
    display: none;
}
.clear {
    clear: both;
}

.subheading {
    font-weight: bold;
}
.highlight {
    font-weight: bold;
}
.lowlight { /* like highlight but less so */
    font-style: italic;
}
.explanation {
    font-style: italic;
}
abbr {
    border-bottom: 1px dashed black;
}
img.emoji {
    margin-bottom: -0.25em;
}
.forCopyPaste {
    /* used to add blank lines that we want when copying text to clipboard,
       but we don't want to see extra whitespace on the screen */
    margin-top: -1em;
}
ul.padded > li {
    padding: 3px 0;
}

.gearList .item .stats {
    font-variant: small-caps;
}
.gearList .item .key {
    display: none;
}


.coloured {
    display: inline-block;
    width: 5.5em;
    height: 3em;
    padding-top: .7em;
}
.colourBrightBlue { background-color: rgb(209,226,248); }
.colourBlueGrey   { background-color: rgb(216,230,232); }
.colourGreen      { background-color: rgb(222,237,219); }
.colourYellow     { background-color: rgb(255,244,216); }
.colourOrange     { background-color: rgb(254,234,216); }
.colourRed        { background-color: rgb(250,214,214); }
.colourDarkRed    { background-color: rgb(240,197,190); }

.neutral {
    background-color: #fffbd0; /* yellow */
}
.danger {
    background-color: #ffcccc; /* red */
}
.safe {
    background-color: #ccffcc; /* green */
}


/*********************************************************************
****   Header   ******************************************************
*********************************************************************/
h1 {
    float: left;
}
h1>a:first-child { /* "Habitica" link in header */
    color: black;
    text-decoration: none;
}
h1>a:first-child:hover { /* "Habitica" link in header */
    text-decoration: underline;
}
h1 span {
    font-size: 0.5em;
}


/*********************************************************************
****   Header   ******************************************************
*********************************************************************/
table {
    width: 100%;
    border-collapse: collapse;
}
table, th, td {
   border: 1px solid black;
}
th em {
    font-weight: normal;
}


</style>
</head>
<body><div id="innerBody">

<!-- XXX_LATER translate header and "fetching" messages -->
<h1><a href="https://habitica.fandom.com/">Habitica Wiki</a> Quest Table Creator
    <span>(last updated 2019-08-18)</span></h1><!-- VERSION -->
<hr class="clear" />

<div id="loading">
    <div class="good hide">
        <p>Please wait. Fetching data from Habitica...</p>
    </div>
    <div class="bad hide">
        <p>There was an error obtaining the data.</p>
        <ul class="padded">
            <li>Please reload the page (but perhaps wait half an hour first in case Habitica is under heavy load).</li>
            <li>If you're using Internet Explorer, try another browser. <a href="https://www.google.com/intl/en/chrome/browser/">Chrome</a> or <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a> will be more reliable.</li>
            <li>If neither of those help, <a href="mailto:lady_alys@oldgods.net">contact me</a>!</li>
        </ul>
    </div>
</div>

<div id="output">
</div>


<br />
<table id="theTable"></table>

<!--
== Table of All Quests in Quest Lines ==
{{:Template:Quest_Table_Quest_Lines}}

<noinclude>
Do not edit this table by hand. Instead, use the "Quest Lines" section in the [https://oldgods.net/habitrpg/quest_table_creator.html Quest Table Creator], which will read the latest "content" data from Habitica and create all the required wikia code. Delete everything below this "noinclude" tag and replace it with that code.
[[Category:Template Tables| ]][[Category:Habitica Templates]]
</noinclude>
-->

</div><!-- end of div id="innerBody" -->
</body>
</html>
